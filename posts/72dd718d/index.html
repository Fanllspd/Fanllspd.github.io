<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="light"><link rel="canonical" href="http://example.com/posts/72dd718d/"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico"><link rel="icon" href="/img/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#dff9fb"><meta name="author" content="Fanllspd"><meta name="keywords" content="blog"><meta name="description" content="[UESTC-信软] iCoding F2 Answer字符串块链串 块链串定义如下： 1234567891011121314151617181920#define BLOCK_SIZE 4    &#x2F;&#x2F; 可由用户定义的块大小#define BLS_BLANK &amp;#x27;#&amp;#x27;   &#x2F;&#x2F; 用于空白处的补齐字符typedef struct _block &amp;#123;    char ch[B"><meta property="og:type" content="article"><meta property="og:title" content="UESTC-iCoding-F2"><meta property="og:url" content="http://example.com/posts/72dd718d/index.html"><meta property="og:site_name" content="Fanllspd&#39;s Blog"><meta property="og:description" content="[UESTC-信软] iCoding F2 Answer字符串块链串 块链串定义如下： 1234567891011121314151617181920#define BLOCK_SIZE 4    &#x2F;&#x2F; 可由用户定义的块大小#define BLS_BLANK &amp;#x27;#&amp;#x27;   &#x2F;&#x2F; 用于空白处的补齐字符typedef struct _block &amp;#123;    char ch[B"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/index_img/uestc.png"><meta property="article:published_time" content="2024-06-07T12:03:18.000Z"><meta property="article:modified_time" content="2024-06-30T16:01:22.973Z"><meta property="article:author" content="Fanllspd"><meta property="article:tag" content="iCoding"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/index_img/uestc.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>UESTC-iCoding-F2 - Fanllspd&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/cloudedGlass.css"><link rel="stylesheet" href="/css/walineBg.css"><link rel="stylesheet" href="/css/scrollAnimation.css"><link rel="stylesheet" href="/css/macpanel.css"><link rel="stylesheet" href="/css/CatLoading.css"><link rel="stylesheet" href="/css/backgroundize.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.5",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!0,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#2299dd",options:{easing:"ease",speed:500,showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")}))</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="cat__scene"><div class="cat__main"><div class="cat__body"></div><div class="cat__body"></div><div class="cat__tail"></div><div class="cat__head"></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>悟已往之不谏，知来者之可追</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span class="nav-link-text">首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span class="nav-link-text">归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span class="nav-link-text">分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span class="nav-link-text">标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span class="nav-link-text">关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span class="nav-link-text">友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/index_img/sise.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="UESTC-iCoding-F2"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Fanllspd </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-06-07 20:03" pubdate>2024年6月7日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 33k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 271 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">UESTC-iCoding-F2</h1><p class="note note-info">本文最后更新于：1 个月前</p><div class="markdown-body"><h1 id="UESTC-信软-iCoding-F2-Answer"><a href="#UESTC-信软-iCoding-F2-Answer" class="headerlink" title="[UESTC-信软] iCoding F2 Answer"></a>[UESTC-信软] iCoding F2 Answer</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="块链串"><a href="#块链串" class="headerlink" title="块链串"></a>块链串</h3><blockquote><p>块链串定义如下：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs h"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_SIZE 4    <span class="hljs-comment">// 可由用户定义的块大小</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLS_BLANK <span class="hljs-string">&#x27;#&#x27;</span>   <span class="hljs-comment">// 用于空白处的补齐字符</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">block</span> &#123;</span><br>    <span class="hljs-type">char</span> ch[BLOCK_SIZE];    <span class="hljs-comment">//块的数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">block</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-comment">//块的指针域</span><br>&#125; Block;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Block *head;        <span class="hljs-comment">// 串的头指针</span><br>    Block *tail;        <span class="hljs-comment">// 串的尾指针</span><br>    <span class="hljs-type">int</span> len;            <span class="hljs-comment">// 串的当前长度</span><br>&#125; BLString;<br><br><span class="hljs-comment">//字符串初始化函数：</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">blstr_init</span><span class="hljs-params">(BLString *T)</span> &#123;<br>    T-&gt;len = <span class="hljs-number">0</span>;<br>    T-&gt;head = <span class="hljs-literal">NULL</span>;<br>    T-&gt;tail = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些定义已包含在头文件 <strong>dsstring.h</strong> 中，请实现块链串的子串查找操作：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs h"><span class="hljs-type">bool</span> <span class="hljs-title function_">blstr_substr</span><span class="hljs-params">(BLString src, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> len, BLString *sub)</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>src</strong>: 为要查找的字符串</li><li><strong>pos</strong>: 为子串开始的下标</li><li><strong>len</strong>: 为子串的长度</li><li><strong>sub</strong>: 在函数调用运行前指向一个已经初始化好的空串，在函数返回时，<strong>sub</strong> 指向串 <strong>src</strong> 从第 <strong>pos</strong> 个字符起长度为 <strong>len</strong> 的子串</li><li>函数查找成功返回 <strong>true</strong>，参数不正确返回 <strong>false</strong></li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dsstring.h&quot;</span> <span class="hljs-comment">// 请不要删除，否则检查不通过</span></span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">blstr_substr</span><span class="hljs-params">(BLString src, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> len, BLString *sub)</span><br>&#123;<br>    <span class="hljs-comment">// if (pos &lt; 0 || len &lt; 0 || pos + len &gt; src.len)</span><br>    <span class="hljs-comment">//     return false;</span><br><br>    <span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>    <span class="hljs-type">int</span> index = pos / BLOCK_SIZE, offset = pos % BLOCK_SIZE;<br>    Block *pBh = src.head;<br><br>    <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (now++ &lt; index)<br>        pBh = pBh-&gt;next;<br><br>    <span class="hljs-type">int</span> counts = <span class="hljs-number">0</span>, counts2 = offset;<br>    <br>    Block *newBlock = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (pBh &amp;&amp; counts &lt; len )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (counts + pos &gt;= src.len)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (counts % BLOCK_SIZE == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// pBh = pBh-&gt;next;</span><br>            newBlock = (Block *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Block));<br>            <span class="hljs-keyword">if</span> (newBlock == <span class="hljs-literal">NULL</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">if</span> (sub-&gt;head)<br>            &#123;<br>                sub-&gt;tail-&gt;next = newBlock;<br>                sub-&gt;tail = sub-&gt;tail-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                sub-&gt;head = sub-&gt;tail = newBlock;<br>            &#125;<br>            sub-&gt;tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        newBlock-&gt;ch[counts++ % BLOCK_SIZE] = pBh-&gt;ch[counts2++ % BLOCK_SIZE];<br><br>        <span class="hljs-keyword">if</span> (counts2 % BLOCK_SIZE == <span class="hljs-number">0</span>)<br>        &#123;<br>            pBh = pBh-&gt;next;<br>            counts2 = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (counts % BLOCK_SIZE != <span class="hljs-number">0</span>)<br>        &#123;<br>            newBlock-&gt;ch[counts % BLOCK_SIZE] = BLS_BLANK;<br>            counts++;<br>        &#125;<br>    sub-&gt;tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (pos + len &gt; src.len)<br>        sub-&gt;len = src.len - pos;<br>    <span class="hljs-keyword">else</span><br>        sub-&gt;len = len;<br>    <br>    <span class="hljs-comment">// free(newBlock);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="串替换"><a href="#串替换" class="headerlink" title="串替换"></a>串替换</h3><blockquote><p><strong>不调用库函数</strong>，自己实现字符串替换操作，函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">str_replace</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *in, <span class="hljs-type">char</span> *out, <span class="hljs-type">int</span> outlen, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldstr, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newstr)</span></span>;<br></code></pre></td></tr></table></figure><p>参数说明:</p><ul><li><strong>in</strong>: 原始字符串，保持不变</li><li><strong>out</strong>: 存放替换结果的字符串</li><li><strong>outlen</strong>: <strong>out</strong>空间的大小</li><li><strong>oldstr</strong>: 要替换的旧字符串</li><li><strong>newstr</strong>: 替换成的新字符串</li><li>函数返回成功替换的次数，即有多少个子串被成功替换</li></ul><p>​	在替换过程中，任何情况下所得字符串（及结束符）不应该超过 <strong>outlen</strong>，如果某次替换所得字符串的长度超过 <strong>outlen</strong>，则不进行这次替换操作，整个替换操作结束。如：<br>​	原始串为 “aaabbbccc”，<strong>outlen</strong> 为 14 , <strong>oldstr</strong> 为 “c”，<strong>newstr</strong> 为 “333” 时，两次替换后得 “aaabbb333333c”，此时字符串占用空间为 14 字节。<br>​	如果再进行替换，则会超出 <strong>out</strong> 所占用的空间，所以停止替换操作。<br>​	此时函数应该返回 2, <strong>out</strong> 指向的串为 “aaabbb333333c”<br>​	再如：原始串为 “aaabbbccc”，<strong>outlen</strong> 为10, <strong>oldstr</strong> 为 “b”，<strong>newstr</strong> 为 “123456”，进行替换后所得的串长度为 14，与结束符一共占 15 个字节，超过 <strong>outlen</strong> 的 10 字节，此时不进行替换，函数应该返回 0。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dsstring.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">str_len</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span> &#123;<br>    <span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (str[length] != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        length++;<br>    <span class="hljs-keyword">return</span> length;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">str_replace</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *in, <span class="hljs-type">char</span> *out, <span class="hljs-type">int</span> outlen,</span><br><span class="hljs-params">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldstr, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newstr)</span><br>&#123;<br>    <span class="hljs-type">int</span> replaceCounts = <span class="hljs-number">0</span>,<br>        lenOfOldstr = str_len(oldstr),<br>        lenOfNewstr = str_len(newstr);<br><br>    <span class="hljs-type">int</span> offset = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; outlen; i++)<br>    &#123;<br>        out[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (in[i] != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> match = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; lenOfOldstr; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (in[i + j] != oldstr[j])<br>            &#123;<br>                match = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (match &amp;&amp; offset + str_len(in) - i - lenOfOldstr + lenOfNewstr &lt; outlen)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; lenOfNewstr; j++)<br>            &#123;<br>                out[offset++] = newstr[j];<br>            &#125;<br><br>            replaceCounts++;<br>            i += lenOfOldstr;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (offset &gt;= outlen - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            out[offset] = in[i];<br>            offset++;<br>            i++;<br>        &#125;<br><br>        <span class="hljs-comment">// i++;</span><br>    &#125;<br>    out[outlen] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> replaceCounts;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="串比较"><a href="#串比较" class="headerlink" title="串比较"></a>串比较</h3><blockquote><p><strong>不调用库函数</strong>，自己实现字符串的比较操作：该操作当比较的两个字符是都是字母，且两个字符互为大小写（如 a 和 A 、 e 和 E ）时认为两个字符相同，否则不同，其比较结果按这两个字符的原值确定。函数的返回值规定如下：</p><ul><li><strong>返回值 &lt; 0</strong>：第一个不匹配的字符在 <strong>ptr1</strong> 中的值低于 <strong>ptr2</strong> 中的值</li><li><strong>返回值 &#x3D;&#x3D; 0</strong>：两个字符串的内容相等</li><li><strong>返回值 &gt; 0</strong>：第一个不匹配的字符在 <strong>ptr1</strong> 中的值大于在 <strong>ptr2</strong> 中的值</li></ul><p>函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">str_compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr2)</span></span>;<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dsstring.h&quot;</span> <span class="hljs-comment">//请不要删除，否则检查不通过</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">str_len</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (str[length] != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        length++;<br>    <span class="hljs-keyword">return</span> length;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">str_compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr2)</span><br>&#123;<br>    <span class="hljs-type">int</span> lenOfPtr1 = str_len(ptr1);<br>    <span class="hljs-type">int</span> lenOfPtr2 = str_len(ptr2);<br>    <span class="hljs-type">int</span> max = lenOfPtr1 &gt;= lenOfPtr2 ? lenOfPtr1 : lenOfPtr2;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; max; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ptr1[i] == ptr2[i])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (ptr1[i] &lt; ptr2[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ptr1[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ptr1[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; (ptr2[i] - ptr1[i] == <span class="hljs-number">32</span>))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">return</span> ptr1[i] - ptr2[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ptr1[i] &gt; ptr2[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ptr1[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ptr1[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> &amp;&amp; (ptr1[i] - ptr2[i] == <span class="hljs-number">32</span>))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">return</span> ptr1[i] - ptr2[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列栈"><a href="#队列栈" class="headerlink" title="队列栈"></a>队列栈</h2><h3 id="栈-后缀表达式计算"><a href="#栈-后缀表达式计算" class="headerlink" title="栈 后缀表达式计算"></a>栈 后缀表达式计算</h3><blockquote><p>请使用已定义好的栈完成后缀表达式计算：</p><ol><li>如果是操作数，直接入栈</li><li>如果是操作符 <strong>op</strong>，连续出栈两次，得到操作数 <strong>x</strong> 和 <strong>y</strong> ,计算 <strong>x op y</strong>，并将结果入栈。</li></ol><p>后缀表达式示例如下：</p><ul><li><strong>9 3 1 - 3 * + 10 2 &#x2F; +</strong></li><li><strong>13 445 + 51 &#x2F; 6 -</strong></li></ul><p>操作数、操作符之间由空格隔开，操作符有 <strong>+<strong>，</strong>-<strong>，</strong></strong>*, <strong>&#x2F;</strong>, **%**共 5 种符号，所有操作数都为整型。</p><p>栈的定义如下：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs h"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Stack_Size 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType elem[Stack_Size];<br>    <span class="hljs-type">int</span> top;<br>&#125;Stack;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Stack* S, ElemType x)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(Stack* S, ElemType *x)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">init_stack</span><span class="hljs-params">(Stack *S)</span>;<br></code></pre></td></tr></table></figure><p>其中，栈初始化的实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init_stack</span><span class="hljs-params">(Stack *S)</span>&#123;<br>    S-&gt;top = <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要完成的函数定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compute_reverse_polish_notation</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span>;<br></code></pre></td></tr></table></figure><p>函数接收一个字符指针，该指针指向一个字符串形式的后缀表达式，函数返回该表达式的计算结果。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span> <span class="hljs-comment">// 请不要删除，否则检查不通过</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">compute_reverse_polish_notation</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span><br>&#123;<br>    Stack <span class="hljs-built_in">stack</span>;<br>    init_stack(&amp;<span class="hljs-built_in">stack</span>);<br>    <span class="hljs-type">char</span> *partStr = strtok(str, <span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-keyword">while</span> (partStr)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(partStr[<span class="hljs-number">0</span>]))<br>            push(&amp;<span class="hljs-built_in">stack</span>, atoi(partStr));<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> x, y;<br>            pop(&amp;<span class="hljs-built_in">stack</span>, &amp;y);<br>            pop(&amp;<span class="hljs-built_in">stack</span>, &amp;x);<br>            <span class="hljs-keyword">switch</span> (partStr[<span class="hljs-number">0</span>])<br>            &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                push(&amp;<span class="hljs-built_in">stack</span>, x + y);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                push(&amp;<span class="hljs-built_in">stack</span>, x - y);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                push(&amp;<span class="hljs-built_in">stack</span>, x * y);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                push(&amp;<span class="hljs-built_in">stack</span>, x / y);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;%&#x27;</span>:<br>                push(&amp;<span class="hljs-built_in">stack</span>, x % y);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        partStr = strtok(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>.elem[<span class="hljs-built_in">stack</span>.top];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="队列-循环链表表示队列"><a href="#队列-循环链表表示队列" class="headerlink" title="队列 循环链表表示队列"></a>队列 循环链表表示队列</h3><blockquote><p>假设以带头结点的循环链表表示队列，并且<strong>只设一个指针指向队尾元素结点</strong>（注意不设头指针），请完成下列任务：</p><ol><li><p>队列初始化，成功返回真，否则返回假：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">init_queue</span><span class="hljs-params">(LinkQueue *LQ)</span>;<br></code></pre></td></tr></table></figure></li><li><p>入队列，成功返回真，否则返回假：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">enter_queue</span><span class="hljs-params">(LinkQueue *LQ, ElemType x)</span>;<br></code></pre></td></tr></table></figure></li><li><p>出队列，成功返回真，且 <strong>*x</strong>为出队的值，否则返回假</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">leave_queue</span><span class="hljs-params">(LinkQueue *LQ, ElemType *x)</span>;<br></code></pre></td></tr></table></figure></li></ol><p>相关定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_QueueNode</span> &#123;<br>    ElemType data;          <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_QueueNode</span> *next;      <span class="hljs-comment">// 指针域</span><br>&#125;LinkQueueNode, *LinkQueue;<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span> <span class="hljs-comment">// 请不要删除，否则检查不通过</span></span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">init_queue</span><span class="hljs-params">(LinkQueue *LQ)</span><br>&#123;<br>    *LQ = (LinkQueue)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkQueueNode));<br>    <span class="hljs-keyword">if</span> (!LQ)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// (*LQ)-&gt;data = NULL;</span><br>    (*LQ)-&gt;next = *LQ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">enter_queue</span><span class="hljs-params">(LinkQueue *LQ, ElemType x)</span><br>&#123;<br>    LinkQueueNode *newQueueNode = (LinkQueueNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkQueueNode));<br>    <span class="hljs-keyword">if</span> (!newQueueNode)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    newQueueNode-&gt;data = x;<br>    newQueueNode-&gt;next = (*LQ)-&gt;next;<br>    (*LQ)-&gt;next = newQueueNode;<br>    (*LQ) = (*LQ)-&gt;next;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">leave_queue</span><span class="hljs-params">(LinkQueue *LQ, ElemType *x)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ((*LQ)-&gt;next == *LQ)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    LinkQueueNode *firstNode = (*LQ)-&gt;next-&gt;next;<br>    *x = firstNode-&gt;data;<br>    (*LQ)-&gt;next-&gt;next = firstNode-&gt;next;<br>    <span class="hljs-keyword">if</span> (firstNode == *LQ) <span class="hljs-comment">// 如果为最后一个</span><br>        *LQ = (*LQ)-&gt;next;<br>    <span class="hljs-built_in">free</span>(firstNode);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="链表-合并"><a href="#链表-合并" class="headerlink" title="链表 合并"></a>链表 合并</h3><blockquote><p>设线性表 <strong>A&#x3D;(a1, a2,…,am)，B&#x3D;(b1, b2,…,bn)<strong>，试写一个按下列规则合并 <strong>A</strong>、</strong>B</strong> 为线性表 <strong>C</strong> 的算法，使得：</p><ul><li><strong>C&#x3D; (a1, b1,…,am, bm, bm+1, …,bn)</strong> 当 <strong>m≤n</strong> 时；</li></ul><p>或者</p><ul><li><strong>C&#x3D; (a1, b1,…,an, bn, an+1, …,am)</strong> 当 <strong>m&gt;n</strong> 时。</li></ul><p>线性表 <strong>A</strong>、<strong>B</strong>、<strong>C</strong> 均以单链表作为存储结构，且 <strong>C</strong> 表利用 <strong>A</strong> 表和 <strong>B</strong> 表中的结点空间构成。注意：单链表的长度值 <strong>m</strong> 和 <strong>n</strong> 均未显式存储。</p><p>函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lnk_merge</span><span class="hljs-params">(LinkList A, LinkList B, LinkList C)</span><br></code></pre></td></tr></table></figure><p>即将 <strong>A</strong> 和 <strong>B</strong> 合并为 <strong>C</strong>，其中 <strong>C</strong> 已经被初始化为空单链表</p><p>相关定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">lnklist</span>&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">lnklist</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">lnklist</span> <span class="hljs-title">Node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">lnklist</span> *<span class="hljs-title">LinkList</span>;</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span> <span class="hljs-comment">// 请不要删除，否则检查不通过</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lnk_merge</span><span class="hljs-params">(LinkList A, LinkList B, LinkList C)</span><br>&#123;<br>    Node *pA = A-&gt;next, *pB = B-&gt;next, *pC = C;<br>    <span class="hljs-comment">// int counts = 0;</span><br>    <span class="hljs-keyword">while</span> (pA &amp;&amp; pB)<br>    &#123;<br>        <span class="hljs-comment">// pC-&gt;next = (Node *)malloc(sizeof(Node));</span><br><br>        pC-&gt;next = pA;<br>        pA = pA-&gt;next;<br>        pC = pC-&gt;next;<br><br>        pC-&gt;next = pB;<br>        pB = pB-&gt;next;<br>        pC = pC-&gt;next;<br>        <span class="hljs-comment">// counts += 2;</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (pA)<br>    &#123;<br>        pC-&gt;next = pA;<br>        pC = pC-&gt;next;<br>        pA = pA-&gt;next;<br>        <span class="hljs-comment">// counts++;</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (pB)<br>    &#123;<br>        pC-&gt;next = pB;<br>        pC = pC-&gt;next;<br>        pB = pB-&gt;next;<br>        <span class="hljs-comment">// counts++;</span><br>    &#125;<br>    <span class="hljs-comment">// printf(&quot;%d&quot;, counts);</span><br>    pC-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表-倒数查找"><a href="#链表-倒数查找" class="headerlink" title="链表 倒数查找"></a>链表 倒数查找</h3><blockquote><p>已知一个带有表头结点的单链表, 假设链表只给出了头指针 <strong>L</strong> 。</p><p>在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第 <strong>k</strong> 个位置上的结点（ <strong>k</strong> 为正整数）。</p><p>函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">lnk_search</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> k, ElemType* p_ele)</span><br></code></pre></td></tr></table></figure><p>若查找成功，函数通过指针参数 <strong>p_ele</strong> 返回该结点 <strong>data</strong> 域的值，此时函数返回 <strong>1</strong>；<br>否则，函数返回 <strong>0</strong> 。</p><p>相关定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">lnklist</span>&#123;</span><br>ElemType data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">lnklist</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">lnklist</span> <span class="hljs-title">Node</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">lnklist</span> *<span class="hljs-title">LinkList</span>;</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span> <span class="hljs-comment">// 请不要删除，否则检查不通过</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">lnk_search</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> k, ElemType* p_ele)</span> &#123;<br>    Node *p1 = L-&gt;next, *p2 = L-&gt;next;<br>    <span class="hljs-type">int</span> counts = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p2-&gt;next)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (counts++ &gt; k)<br>            p1 = p1-&gt;next;<br>        p2 = p2-&gt;next;<br>    &#125;<br>    *p_ele = p1-&gt;data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表-删除范围内结点"><a href="#链表-删除范围内结点" class="headerlink" title="链表 删除范围内结点"></a>链表 删除范围内结点</h3><blockquote><p>已知线性表中的元素（整数）以值递增有序排列，并以单链表作存储结构。</p><p>试写一高效算法，删除表中所有大于 <strong>mink</strong> 且小于 <strong>maxk</strong> 的元素（若表中存在这样的元素），分析你的算法的时间复杂度。</p><p>链表结点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_lnklist</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_lnklist</span> *next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_lnklist</span> Node;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_lnklist</span> *LinkList;<br></code></pre></td></tr></table></figure><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lnk_del_x2y</span><span class="hljs-params">(LinkList L, ElemType mink, ElemType maxk)</span><br></code></pre></td></tr></table></figure><p>其中L指向链表的头结点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span> <span class="hljs-comment">// 请不要删除，否则检查不通过</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lnk_del_x2y</span><span class="hljs-params">(LinkList L, ElemType mink, ElemType maxk)</span> <br>&#123;<br>    Node *pL = L, *temp = L-&gt;next;<br>    <span class="hljs-keyword">while</span> (pL-&gt;next &amp;&amp; pL-&gt;next-&gt;data &lt;= mink)<br>    &#123;<br>        pL = pL-&gt;next;<br>    &#125;<br><br>    temp = pL-&gt;next;<br>    <span class="hljs-keyword">while</span> (pL-&gt;next &amp;&amp; pL-&gt;next-&gt;data &lt; maxk)<br>    &#123;<br>        pL-&gt;next = temp-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>        temp = pL-&gt;next;<br>        <span class="hljs-comment">// break;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序表-数据调整"><a href="#顺序表-数据调整" class="headerlink" title="顺序表 数据调整"></a>顺序表 数据调整</h3><blockquote><p>已知顺序表 <strong>L</strong> 中的数据元素类型为 <strong>int</strong> 。</p><p>设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为 <strong>O(n)</strong> ,空间复杂度为 <strong>O(1)</strong> 。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">odd_even</span><span class="hljs-params">(SeqList *L)</span>;<br></code></pre></td></tr></table></figure><p>相关定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">seqlist</span>&#123;</span><br>    ElemType elem[MAXSIZE];<br>    <span class="hljs-type">int</span> last;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">seqlist</span> <span class="hljs-title">SeqList</span>;</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span> <span class="hljs-comment">// 请不要删除，否则检查不通过</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">odd_even</span><span class="hljs-params">(SeqList *L)</span><br>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,<br>        right = L-&gt;last,<br>        temp = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right)<br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (L-&gt;elem[left] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; L-&gt;elem[right] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>        &#123;<br>            temp = L-&gt;elem[right];<br>            L-&gt;elem[right] = L-&gt;elem[left];<br>            L-&gt;elem[left] = temp;<br>            right--;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (L-&gt;elem[left] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>            left++;<br><br>        <span class="hljs-keyword">if</span> (L-&gt;elem[right] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>            right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序表-删除重复"><a href="#顺序表-删除重复" class="headerlink" title="顺序表 删除重复"></a>顺序表 删除重复</h3><blockquote><p>编写算法，在一非递减的顺序表 <strong>L</strong> 中，删除所有值相等的多余元素。要求时间复杂度为 **O(n)**，空间复杂度为 **O(1)**。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">del_dupnum</span><span class="hljs-params">(SeqList *L)</span><br></code></pre></td></tr></table></figure><p>相关定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">seqlist</span>&#123;</span><br>    ElemType elem[MAXSIZE];<br>    <span class="hljs-type">int</span> last;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">seqlist</span> <span class="hljs-title">SeqList</span>;</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span> <span class="hljs-comment">// 请不要删除，否则检查不通过</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">del_dupnum</span><span class="hljs-params">(SeqList *L)</span><br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>[<span class="hljs-number">1001</span>] = &#123;<span class="hljs-number">0</span>&#125;,<br>        i = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// SeqList newList;</span><br>    <span class="hljs-comment">// newList.last = -1;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; L-&gt;last + <span class="hljs-number">1</span>; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[L-&gt;elem[j]] == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">map</span>[L-&gt;elem[j]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// newList.elem[++newList.last] = L-&gt;elem[j];</span><br>            L-&gt;elem[i++] = L-&gt;elem[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// *L = newList;</span><br>    L-&gt;last = i - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序表-删除指定范围"><a href="#顺序表-删除指定范围" class="headerlink" title="顺序表 删除指定范围"></a>顺序表 删除指定范围</h3><blockquote><p>设计一个高效的算法，从顺序表 <strong>L</strong> 中删除所有值介于 <strong>x</strong> 和 <strong>y</strong> 之间（包括 <strong>x</strong> 和 <strong>y</strong> ）的所有元素（假设 <strong>y&gt;&#x3D;x</strong> ），要求时间复杂度为 <strong>O(n)</strong> ，空间复杂度为 <strong>O(1)</strong> 。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">del_x2y</span><span class="hljs-params">(SeqList *L, ElemType x, ElemType y)</span>;<br></code></pre></td></tr></table></figure><p>相关定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">seqlist</span>&#123;</span><br>    ElemType elem[MAXSIZE];<br>    <span class="hljs-type">int</span> last;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">seqlist</span> <span class="hljs-title">SeqList</span>;</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span> <span class="hljs-comment">// 请不要删除，否则检查不通过</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">del_x2y</span><span class="hljs-params">(SeqList *L, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; L-&gt;last + <span class="hljs-number">1</span>; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (L-&gt;elem[j] &lt; x || L-&gt;elem[j] &gt; y)<br>        &#123;<br>            L-&gt;elem[i++] = L-&gt;elem[j];<br>        &#125;<br>    &#125;<br>    L-&gt;last = i - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><blockquote><p>试在邻接矩阵存储结构上实现图的基本操作 <strong>matrix_insert_vertex</strong> 和<strong>matrix_insert_arc</strong>，相关定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> VertexType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;<br>    DG, UDG<br>&#125;GraphType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    VertexType vertex[MAX_VERTEX_NUM]; <span class="hljs-comment">//顶点向量</span><br>    <span class="hljs-type">int</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; <span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;   <span class="hljs-comment">//图的当前顶点数和弧数</span><br>    GraphType type;     <span class="hljs-comment">//图的种类标志</span><br>&#125;MatrixGraph;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">matrix_locate_vertex</span><span class="hljs-params">(MatrixGraph *MG, VertexType vex)</span></span>; <span class="hljs-comment">//返回顶点 v 在vertex数组中的下标，如果v不存在，返回-1</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">matrix_insert_vertex</span><span class="hljs-params">(MatrixGraph *G, VertexType v)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">matrix_insert_arc</span><span class="hljs-params">(MatrixGraph *G, VertexType v, VertexType w)</span></span>;<br></code></pre></td></tr></table></figure><p>当成功插入顶点或边时，函数返回 <strong>true</strong>，否则（如顶点或边已存在、插入边时顶点 <strong>v</strong> 或 <strong>w</strong> 不存在）返回 <strong>false</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;graph.h&quot;</span> <span class="hljs-comment">// 请不要删除，否则检查不通过</span></span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">matrix_insert_vertex</span><span class="hljs-params">(MatrixGraph *G, VertexType v)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (G-&gt;vexnum &lt; MAX_VERTEX_NUM)<br>        <span class="hljs-keyword">if</span> (matrix_locate_vertex(G, v) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            G-&gt;vertex[G-&gt;vexnum++] = v;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexnum; i++)<br>                G-&gt;arcs[i][G-&gt;vexnum - <span class="hljs-number">1</span>] = G-&gt;arcs[G-&gt;vexnum - <span class="hljs-number">1</span>][i] = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">matrix_insert_arc</span><span class="hljs-params">(MatrixGraph *G, VertexType v, VertexType w)</span><br>&#123;<br>    <span class="hljs-type">int</span> vLoc = matrix_locate_vertex(G, v);<br>    <span class="hljs-type">int</span> wLoc = matrix_locate_vertex(G, w);<br>    <span class="hljs-keyword">if</span> (vLoc != <span class="hljs-number">-1</span> &amp;&amp; wLoc != <span class="hljs-number">-1</span> &amp;&amp; G-&gt;arcs[vLoc][wLoc] != <span class="hljs-number">1</span>)<br>    &#123;<br>        G-&gt;arcs[vLoc][wLoc] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (G-&gt;type == UDG)<br>            G-&gt;arcs[wLoc][vLoc] = <span class="hljs-number">1</span>;<br>        G-&gt;arcnum++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接表1"><a href="#邻接表1" class="headerlink" title="邻接表1"></a>邻接表1</h3><blockquote><p>试在邻接表存储结构上实现图的基本操作 <strong>insert_vertex</strong> 和 <strong>insert_arc</strong>，相关定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> VertexType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;<br>    DG, UDG<br>&#125;GraphType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span><br>&#123;<br>    <span class="hljs-type">int</span> adjvex;<br>    InfoPtr *info;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span> *nextarc;<br><br>&#125;ArcNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span><br>&#123;<br>    VertexType data;<br>    ArcNode *firstarc;<br>&#125;VNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    VNode vertex[MAX_VERTEX_NUM];<br>    <span class="hljs-type">int</span> vexnum, arcnum;<br>    GraphType type;<br>&#125;ListGraph;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">locate_vertex</span><span class="hljs-params">(ListGraph* G, VertexType v)</span></span>; <span class="hljs-comment">//返回顶点 v 在vertex数组中的下标，如果v不存在，返回-1</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insert_vertex</span><span class="hljs-params">(ListGraph *G, VertexType v)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insert_arc</span><span class="hljs-params">(ListGraph *G, VertexType v, VertexType w)</span></span>;<br></code></pre></td></tr></table></figure><p>当成功插入顶点或边时，函数返回 <strong>true</strong>，否则（如顶点或边已存在、插入边时顶点 <strong>v</strong> 或 <strong>w</strong> 不存在）返回 <strong>false</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;graph.h&quot;</span> <span class="hljs-comment">//请勿删除，否则检查不通过</span></span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">insert_vertex</span><span class="hljs-params">(ListGraph *G, VertexType v)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (G-&gt;vexnum &lt; MAX_VERTEX_NUM)<br>        <span class="hljs-keyword">if</span> (locate_vertex(G, v) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            VNode newNode = &#123;v, <span class="hljs-literal">NULL</span>&#125;;<br>            G-&gt;vertex[G-&gt;vexnum++] = newNode;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">insert_arc</span><span class="hljs-params">(ListGraph *G, VertexType v, VertexType w)</span><br>&#123;<br>    <span class="hljs-type">int</span> vLoc = locate_vertex(G, v);<br>    <span class="hljs-type">int</span> wLoc = locate_vertex(G, w);<br>    <span class="hljs-keyword">if</span> (vLoc == <span class="hljs-number">-1</span> || wLoc == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    ArcNode *vArcNode = G-&gt;vertex[vLoc].firstarc;<br><br>    <span class="hljs-keyword">while</span> (vArcNode)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (vArcNode-&gt;adjvex == wLoc)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vArcNode = vArcNode-&gt;nextarc; <span class="hljs-comment">// 检查(v,w)重复</span><br>    &#125;<br>    ArcNode *newNode = (ArcNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ArcNode));<br>    <span class="hljs-keyword">if</span> (newNode == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    newNode-&gt;adjvex = wLoc;<br><br>    newNode-&gt;nextarc = G-&gt;vertex[vLoc].firstarc;<br>    G-&gt;vertex[vLoc].firstarc = newNode; <span class="hljs-comment">// 头插</span><br><br>    <span class="hljs-comment">// if (G-&gt;type == UDG)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     ArcNode *wArcNode = G-&gt;vertex[wLoc].firstarc;</span><br>    <span class="hljs-comment">//     while (wArcNode)</span><br>    <span class="hljs-comment">//     &#123;</span><br>    <span class="hljs-comment">//         if (wArcNode-&gt;adjvex == vLoc)</span><br>    <span class="hljs-comment">//             return false;</span><br>    <span class="hljs-comment">//         wArcNode = wArcNode-&gt;nextarc; // 检查(w,v)重复</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     newNode-&gt;adjvex = vLoc;</span><br>    <span class="hljs-comment">//     newNode-&gt;nextarc = G-&gt;vertex[wLoc].firstarc;</span><br>    <span class="hljs-comment">//     G-&gt;vertex[vLoc].firstarc = newNode;</span><br>    <span class="hljs-comment">//     // G-&gt;arcnum++;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 貌似不用考虑无向图？</span><br>    G-&gt;arcnum++;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接表2"><a href="#邻接表2" class="headerlink" title="邻接表2"></a>邻接表2</h3><blockquote><p>试在邻接表存储结构上实现图的基本操作 <strong>del_vertex</strong>，相关定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> VertexType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;<br>    DG, UDG<br>&#125;GraphType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>&#123;<br>    <span class="hljs-type">int</span> adjvex;<br>    InfoPtr *info;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span> *nextarc;<br>&#125;ArcNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span>&#123;<br>    VertexType data;<br>    ArcNode *firstarc;<br>&#125;VNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    VNode vertex[MAX_VERTEX_NUM];<br>    <span class="hljs-type">int</span> vexnum, arcnum;<br>    GraphType type;<br>&#125;ListGraph;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">locate_vertex</span><span class="hljs-params">(ListGraph *G, VertexType v)</span></span>; <span class="hljs-comment">//返回顶点 v 在vertex数组中的下标，如果v不存在，返回-1</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">del_vertex</span><span class="hljs-params">(ListGraph *G, VertexType v)</span></span>; <span class="hljs-comment">//删除顶点 v</span><br></code></pre></td></tr></table></figure><p>当成功删除顶点或边时，函数返回 <strong>true</strong>，否则（如顶点或边不存在、删除边时顶点 <strong>v</strong> 或 <strong>w</strong> 不存在）返回 <strong>false</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;graph.h&quot;</span> <span class="hljs-comment">//请勿删除，否则检查不通过</span></span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">del_vertex</span><span class="hljs-params">(ListGraph *G, VertexType v)</span><br>&#123;<br>    <span class="hljs-type">int</span> vLoc = locate_vertex(G, v);<br>    <span class="hljs-keyword">if</span> (vLoc == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexnum; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i == vLoc)<br>        &#123;<br>            <span class="hljs-comment">// G-&gt;vertex[vLoc].data = -1;</span><br>            ArcNode *arcNode = G-&gt;vertex[vLoc].firstarc;<br>            <span class="hljs-keyword">while</span> (arcNode)<br>            &#123;<br>                ArcNode *temp = arcNode;<br>                arcNode = arcNode-&gt;nextarc;<br>                <span class="hljs-built_in">free</span>(temp);<br>                G-&gt;arcnum--;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        ArcNode *prev = <span class="hljs-literal">NULL</span>;<br>        ArcNode *arcNode = G-&gt;vertex[i].firstarc;<br>        <span class="hljs-keyword">while</span> (arcNode)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (arcNode-&gt;adjvex == vLoc)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (prev)<br>                    prev-&gt;nextarc = arcNode-&gt;nextarc;<br>                <span class="hljs-keyword">else</span><br>                    G-&gt;vertex[i].firstarc = arcNode-&gt;nextarc;<br><br>                <span class="hljs-comment">// ArcNode *arcNodeDeleted = arcNode-&gt;nextarc;</span><br>                <span class="hljs-comment">// prev-&gt;nextarc = arcNode-&gt;nextarc;</span><br>                <span class="hljs-built_in">free</span>(arcNode);<br>                G-&gt;arcnum--;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            prev = arcNode;<br>            arcNode = arcNode-&gt;nextarc;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = vLoc; i &lt; G-&gt;vexnum - <span class="hljs-number">1</span>; i++)<br>        G-&gt;vertex[i] = G-&gt;vertex[i + <span class="hljs-number">1</span>];<br><br>    G-&gt;vexnum--;<br><br>    <span class="hljs-comment">// 更新部分原有节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexnum; i++)<br>    &#123;<br>        ArcNode *arcNode = G-&gt;vertex[i].firstarc;<br>        <span class="hljs-keyword">while</span> (arcNode)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (arcNode-&gt;adjvex &gt; vLoc)<br>                arcNode-&gt;adjvex--;<br>            arcNode = arcNode-&gt;nextarc;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树二叉树"><a href="#树二叉树" class="headerlink" title="树二叉树"></a>树二叉树</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><blockquote><p>已知二叉树按照二叉链表方式存储，利用栈的基本操作写出先序遍历非递归形式的算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre_order</span><span class="hljs-params">(BiTree root)</span></span>;<br></code></pre></td></tr></table></figure><p>在遍历过程中，<strong>pre_order</strong> 函数需要调用 <strong>visit_node</strong> 函数来实现对结点的访问，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit_node</span><span class="hljs-params">(BiTNode *node)</span></span>;<br></code></pre></td></tr></table></figure><p>二叉树的相关定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> DataType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    DataType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* left;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* right;<br>&#125;BiTNode, *BiTree;<br></code></pre></td></tr></table></figure><p>遍历所使用栈的相关操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Stack_Size 50</span><br><span class="hljs-keyword">typedef</span> BiTNode* ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType elem[Stack_Size];<br>    <span class="hljs-type">int</span> top;<br>&#125;Stack;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_stack</span><span class="hljs-params">(Stack *S)</span></span>; <span class="hljs-comment">// 初始化栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack* S, ElemType x)</span></span>; <span class="hljs-comment">//x 入栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack* S, ElemType *px)</span></span>; <span class="hljs-comment">//出栈，元素保存到px所指的单元，函数返回true,栈为空时返回 false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">top</span><span class="hljs-params">(Stack* S, ElemType *px)</span></span>; <span class="hljs-comment">//获取栈顶元素，将其保存到px所指的单元，函数返回true，栈满时返回 false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(Stack* S)</span></span>;  <span class="hljs-comment">// 栈为空时返回 true，否则返回 false</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bitree.h&quot;</span> <span class="hljs-comment">//请不要删除，否则检查不通过</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pre_order</span><span class="hljs-params">(BiTree root)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    Stack s;<br>    init_stack(&amp;s);<br>    BiTree current = root;<br>    push(&amp;s, current);<br><br>    <span class="hljs-keyword">while</span> (!is_empty(&amp;s))<br>    &#123;<br>        <span class="hljs-comment">// BiTree node = (BiTree)malloc(sizeof(BiTree));</span><br>        <span class="hljs-comment">// top(&amp;s, &amp;node);</span><br>        pop(&amp;s, &amp;current);<br>        visit_node(current);<br><br>        <span class="hljs-keyword">if</span> (current-&gt;right)<br>            push(&amp;s, current-&gt;right);<br>        <span class="hljs-keyword">if</span> (current-&gt;left)<br>            push(&amp;s, current-&gt;left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><blockquote><p>假设二叉树采用二叉链表方式存储， <strong>root</strong> 指向根结点，<strong>node</strong> 指向二叉树中的一个结点，编写函数 <strong>path</strong>，计算 <strong>root</strong> 到 <strong>node</strong> 之间的路径，（该路径包括 <strong>root</strong> 结点和 <strong>node</strong> 结点）。</p><p><strong>path</strong> 函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">path</span><span class="hljs-params">(BiTNode* root, BiTNode* node, Stack* s)</span>;<br></code></pre></td></tr></table></figure><p>其中，<strong>root</strong> 指向二叉树的根结点，<strong>node</strong> 指向二叉树中的另一结点，<strong>s</strong> 为已经初始化好的栈，该栈用来保存函数所计算的路径，如正确找出路径，则函数返回 <strong>true</strong>，此时 <strong>root</strong> 在栈底，<strong>node</strong> 在栈顶；如未找到，则函数返回 <strong>false</strong>, 二叉树的相关定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> DataType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br> DataType data;<br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* left;<br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* right;<br>&#125;BiTNode, *BiTree;<br></code></pre></td></tr></table></figure><p>栈的相关定义及操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Stack_Size 50</span><br><span class="hljs-keyword">typedef</span> BiTNode* ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br> ElemType elem[Stack_Size];<br> <span class="hljs-type">int</span> top;<br>&#125;Stack;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_stack</span><span class="hljs-params">(Stack *S)</span>; <span class="hljs-comment">// 初始化栈</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Stack* S, ElemType x)</span>; <span class="hljs-comment">//x 入栈</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(Stack* S, ElemType *px)</span>; <span class="hljs-comment">//出栈，元素保存到px所指的单元，函数返回true,栈为空时返回 false</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">top</span><span class="hljs-params">(Stack* S, ElemType *px)</span>; <span class="hljs-comment">//获取栈顶元素，将其保存到px所指的单元，函数返回true，栈满时返回 false</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">is_empty</span><span class="hljs-params">(Stack* S)</span>;  <span class="hljs-comment">// 栈为空时返回 true，否则返回 false</span><br></code></pre></td></tr></table></figure><p>在提示中，树用缩进的形式展示</p><p>如二叉树 <img src="/posts/72dd718d/tree_121.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%">，其缩进形式为：<img src="/posts/72dd718d/tree_121_2.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%">。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bitree.h&quot;</span> <span class="hljs-comment">//请不要删除，否则检查不通过</span></span><br><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">path</span><span class="hljs-params">(BiTNode *root, BiTNode *node, Stack *s)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || node == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    push(s, root);<br><br>    <span class="hljs-keyword">if</span> (root == node)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">if</span> (path(root-&gt;left, node, s) || path(root-&gt;right, node, s))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    pop(s, &amp;(s-&gt;elem[s-&gt;top]));<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="共同祖先"><a href="#共同祖先" class="headerlink" title="共同祖先"></a>共同祖先</h3><blockquote><p>假设二叉树采用二叉链表方式存储， <strong>root</strong> 指向根结点，<strong>p</strong> 所指结点和 <strong>q</strong> 所指结点为二叉树中的两个结点，编写一个计算它们的最近的共同祖先，函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BiTNode * <span class="hljs-title">nearest_ancestor</span><span class="hljs-params">(BiTree root, BiTNode *p, BiTNode *q)</span></span>;<br></code></pre></td></tr></table></figure><p>其中 <strong>root</strong> 指向二叉树的根结点，<strong>p</strong> 和 <strong>q</strong> 分别指向二叉树中的两个结点。<br>提示：在完成本题时，可利用 <strong>path</strong> 函数获取 <strong>p</strong> 和 <strong>q</strong> 两个结点到根结点之间的路径，之后再计算两条公共路径得出最近的共同祖先。</p><p><strong>path</strong> 函数及栈相关定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">path</span><span class="hljs-params">(BiTNode* root, BiTNode* node, Stack* s)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Stack_Size 50</span><br><span class="hljs-keyword">typedef</span> BiTNode* ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br> ElemType elem[Stack_Size];<br> <span class="hljs-type">int</span> top;<br>&#125;Stack;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_stack</span><span class="hljs-params">(Stack *S)</span></span>; <span class="hljs-comment">// 初始化栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack* S, ElemType x)</span></span>; <span class="hljs-comment">//x 入栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack* S, ElemType *px)</span></span>; <span class="hljs-comment">//出栈，元素保存到px所指的单元，函数返回true,栈为空时返回 false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">top</span><span class="hljs-params">(Stack* S, ElemType *px)</span></span>; <span class="hljs-comment">//获取栈顶元素，将其保存到px所指的单元，函数返回true，栈满时返回 false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(Stack* S)</span></span>;  <span class="hljs-comment">// 栈为空时返回 true，否则返回 false</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bitree.h&quot;</span> <span class="hljs-comment">//请不要删除，否则检查不通过</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(Stack *p, Stack *q)</span><br>&#123;<br>    Stack tmp = *p;<br>    *p = *q;<br>    *q = tmp;<br>&#125;<br><br>BiTNode *<span class="hljs-title function_">nearest_ancestor</span><span class="hljs-params">(BiTree root, BiTNode *p, BiTNode *q)</span><br>&#123;<br>    Stack sP, sQ;<br><br>    init_stack(&amp;sP);<br>    init_stack(&amp;sQ);<br><br>    <span class="hljs-keyword">if</span> (!path(root, p, &amp;sP) || !path(root, q, &amp;sQ))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (sP.top &lt; sQ.top)<br>        swap(&amp;sP, &amp;sQ);<br><br>    BiTree nodeP, nodeQ;<br>    <span class="hljs-keyword">while</span> (sP.top != sQ.top)<br>        pop(&amp;sP, &amp;nodeP);<br><br>    <span class="hljs-keyword">while</span> (!is_empty(&amp;sP) &amp;&amp; !is_empty(&amp;sQ))<br>    &#123;<br>        pop(&amp;sP, &amp;nodeP);<br>        pop(&amp;sQ, &amp;nodeQ);<br>        <span class="hljs-keyword">if</span> (nodeP == nodeQ)<br>            <span class="hljs-keyword">return</span> nodeP;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树转二叉树"><a href="#树转二叉树" class="headerlink" title="树转二叉树"></a>树转二叉树</h3><blockquote><p>使用队列，编写 <strong>transfrom</strong> 函数，将普通树转换成对应的二叉树。二叉树的相关定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> DataType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    DataType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* left;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* right;<br>&#125;BiTNode, *BiTree;<br></code></pre></td></tr></table></figure><p>普通树节点的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CHILDREN_NUM 5</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_CSNode</span><br>&#123;<br>    DataType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_CSNode</span> *children[MAX_CHILDREN_NUM];<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_CSNode</span> CSNode;<br></code></pre></td></tr></table></figure><p>其中，子树的根节点的指针存放在 <strong>children</strong> 数组的前 <strong>k</strong> 个元素中，即如果 <strong>children[i]</strong> 的值为 <strong>NULL</strong> ，而 <strong>children[i-1]</strong> 不为 <strong>NULL</strong> ，则表明该结点只有 <strong>i</strong> 棵子树，子树根结点分别保存在 <strong>children[0]</strong> 至 <strong>children[i-1]</strong> 中。</p><p>队列相关定义及操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__Queue</span><br>&#123;<br>    <span class="hljs-type">int</span> i, j; <span class="hljs-comment">//指向数组内元素的游标</span><br>    <span class="hljs-type">void</span> **array;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__Queue</span> Queue;<br><br><span class="hljs-function">Queue* <span class="hljs-title">create_queue</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//创建队列</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_empty_queue</span><span class="hljs-params">(Queue *tree)</span></span>; <span class="hljs-comment">//队为空返回true,不为空时返回false</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">del_queue</span><span class="hljs-params">(Queue *tree)</span></span>; <span class="hljs-comment">//结点指针出队</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_queue</span><span class="hljs-params">(Queue *tree, <span class="hljs-type">void</span> *node)</span></span>; <span class="hljs-comment">//结点指针入队</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free_queue</span><span class="hljs-params">(Queue *tree)</span></span>; <span class="hljs-comment">//释放队列</span><br></code></pre></td></tr></table></figure><p><strong>transform</strong> 函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BiTNode* <span class="hljs-title">transform</span><span class="hljs-params">(CSNode *root)</span></span>;<br></code></pre></td></tr></table></figure><p>其中 <strong>root</strong> 为普通树的根结点，函数返回该树对应二叉树的根结点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bitree.h&quot;</span> <span class="hljs-comment">//请不要删除，否则检查不通过</span></span><br><br><br>BiTNode *<span class="hljs-title function_">transform</span><span class="hljs-params">(CSNode *root)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    BiTree biTree = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>    biTree-&gt;data = root-&gt;data;<br>    biTree-&gt;left = biTree-&gt;right = <span class="hljs-literal">NULL</span>;<br><br>    Queue *<span class="hljs-built_in">queue</span> = create_queue();<br>    Queue *BiQueue = create_queue();<br>    add_queue(<span class="hljs-built_in">queue</span>, root);<br>    add_queue(BiQueue, biTree);<br>    <span class="hljs-comment">// bool a = is_empty_queue(queue);</span><br>    <span class="hljs-keyword">while</span> (!is_empty_queue(<span class="hljs-built_in">queue</span>))<br>    &#123;<br>        CSNode *csNode = del_queue(<span class="hljs-built_in">queue</span>);<br>        BiTree biNode = del_queue(BiQueue);<br><br>        BiTree biPtr = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CHILDREN_NUM; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (csNode-&gt;children[i])<br>            &#123;<br>                BiTree newBiNode = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));<br>                newBiNode-&gt;data = csNode-&gt;children[i]-&gt;data;<br>                newBiNode-&gt;left = newBiNode-&gt;right = <span class="hljs-literal">NULL</span>;<br><br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>                    (biNode)-&gt;left = newBiNode;<br>                <span class="hljs-keyword">else</span><br>                    (biPtr)-&gt;right = newBiNode;<br>                biPtr = newBiNode;<br><br>                add_queue(<span class="hljs-built_in">queue</span>, csNode-&gt;children[i]);<br>                add_queue(BiQueue, newBiNode);<br>            &#125;<br>        &#125;<br>    &#125;<br>    free_queue(<span class="hljs-built_in">queue</span>);<br>    free_queue(BiQueue);<br>    <span class="hljs-keyword">return</span> biTree;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组广义表"><a href="#数组广义表" class="headerlink" title="数组广义表"></a>数组广义表</h2><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><blockquote><p>十字链表相关定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-comment">// 非零元素结点结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OLNode</span><br>&#123;<br>    <span class="hljs-type">int</span> row,col;<br>    ElemType value;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OLNode</span> *right,*down;<br>&#125;OLNode,*OLink;<br><br><span class="hljs-comment">// 十字链表结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    OLink *rowhead,*colhead;<br>    <span class="hljs-type">int</span> rows,cols,nums;<br>&#125;CrossList, *PCrossList;<br></code></pre></td></tr></table></figure><ol><li><p>实现十字链表的初始化操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">init_cross_list</span><span class="hljs-params">(PCrossList L, <span class="hljs-type">const</span> ElemType *A, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure><p>其中 <strong>L</strong> 指向 <strong>CrossList</strong> 结构，且各成员已被初始化为 <strong>0</strong> ；<br><strong>A</strong> 为 <strong>ElemType</strong> 类型数组中第一个元素的地址，元素的个数为 <strong>m×n</strong> 个，按行优先存储（即 <strong>A[0]</strong> 为十字链表第 <strong>1</strong> 行第 <strong>1</strong> 列的元素；<br><strong>A[1]</strong> 为第 <strong>1</strong> 行第 <strong>2</strong> 列的元素，<strong>A[n]</strong> 为第 <strong>2</strong> 行第 <strong>1</strong> 列的元素，<strong>A[n+1]</strong> 为第 <strong>2</strong> 行第 <strong>2</strong> 个元素）；<br><strong>m</strong> 表示十字链表的行数，<strong>n</strong> 表示十字链表的列数。<br><strong>init_cross_list</strong> 函数将 <strong>ElemType</strong> 数组中非 <strong>0</strong> 元素保存到十字链表中，函数返回非 <strong>0</strong> 元素的个数。</p></li><li><p>实现十字链表的删除操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">del_cross_list</span><span class="hljs-params">(PCrossList L, ElemType k)</span></span>;<br></code></pre></td></tr></table></figure><p>其中 <strong>L</strong> 指向 要处理的 <strong>CrossList</strong> 结构，<strong>k</strong> 为要删除的元素；<br><strong>del_cross_list</strong> 函数删除十字链表中所有值为 <strong>k</strong> 的结点，并返回删除结点的个数。</p></li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;crosslist.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">init_cross_list</span><span class="hljs-params">(PCrossList L, <span class="hljs-type">const</span> ElemType *A, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span><br>&#123;<br>    L-&gt;rows = m;<br>    L-&gt;cols = n;<br>    L-&gt;nums = <span class="hljs-number">0</span>;<br>    L-&gt;rowhead = (OLink *)<span class="hljs-built_in">calloc</span>(m, <span class="hljs-keyword">sizeof</span>(OLink));<br>    L-&gt;colhead = (OLink *)<span class="hljs-built_in">calloc</span>(n, <span class="hljs-keyword">sizeof</span>(OLink));<br>    <br>    OLNode *rowPtr = <span class="hljs-literal">NULL</span>,<br>           *colPtr = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-comment">// A[i*n+j]</span><br>            <span class="hljs-keyword">if</span> (A[i * n + j] != <span class="hljs-number">0</span>)<br>            &#123;<br>                OLNode *olNode = (OLNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(OLNode));<br>                <span class="hljs-keyword">if</span> (olNode == <span class="hljs-literal">NULL</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>                olNode-&gt;row = i + <span class="hljs-number">1</span>;<br>                olNode-&gt;col = j + <span class="hljs-number">1</span>;<br>                olNode-&gt;value = A[i * n + j];<br>                olNode-&gt;right = <span class="hljs-literal">NULL</span>;<br>                olNode-&gt;down = <span class="hljs-literal">NULL</span>;<br><br>                <span class="hljs-keyword">if</span> (L-&gt;rowhead[i] == <span class="hljs-literal">NULL</span>)<br>                &#123;<br>                    olNode-&gt;right = L-&gt;rowhead[i];<br>                    L-&gt;rowhead[i] = olNode;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    rowPtr = L-&gt;rowhead[i];<br>                    <span class="hljs-keyword">while</span> (rowPtr-&gt;right)<br>                        rowPtr = rowPtr-&gt;right;<br>                    olNode-&gt;right = <span class="hljs-literal">NULL</span>;<br>                    rowPtr-&gt;right = olNode;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (L-&gt;colhead[j] == <span class="hljs-literal">NULL</span>)<br>                &#123;<br>                    olNode-&gt;down = L-&gt;colhead[j];<br>                    L-&gt;colhead[j] = olNode;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    colPtr = L-&gt;colhead[j];<br>                    <span class="hljs-keyword">while</span> (colPtr-&gt;down)<br>                        colPtr = colPtr-&gt;down;<br>                    olNode-&gt;down = <span class="hljs-literal">NULL</span>;<br>                    colPtr-&gt;down = olNode;<br>                &#125;<br><br>                L-&gt;nums++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> L-&gt;nums;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">del_cross_list</span><span class="hljs-params">(PCrossList L, ElemType k)</span><br>&#123;<br>    OLNode *temp = <span class="hljs-literal">NULL</span>, *prev = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-type">int</span> delCnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L-&gt;rows; i++)<br>    &#123;<br>        prev = <span class="hljs-literal">NULL</span>;<br>        OLNode *rowPtr = L-&gt;rowhead[i];<br>        <span class="hljs-keyword">while</span> (rowPtr)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (rowPtr-&gt;value == k)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">NULL</span>)<br>                    L-&gt;rowhead[i] = rowPtr-&gt;right;<br>                <span class="hljs-keyword">else</span><br>                    prev-&gt;right = rowPtr-&gt;right;<br><br>                rowPtr = rowPtr-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                prev = rowPtr;<br>                rowPtr = rowPtr-&gt;right;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L-&gt;cols; i++)<br>    &#123;<br>        prev = <span class="hljs-literal">NULL</span>;<br>        OLNode *colPtr = L-&gt;colhead[i];<br>        <span class="hljs-keyword">while</span> (colPtr)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (colPtr-&gt;value == k)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">NULL</span>)<br>                    L-&gt;colhead[i] = colPtr-&gt;down;<br>                <span class="hljs-keyword">else</span><br>                    prev-&gt;down = colPtr-&gt;down;<br>                temp = colPtr;<br>                colPtr = colPtr-&gt;down;<br>                <span class="hljs-built_in">free</span>(temp);<br>                L-&gt;nums--;<br>                delCnt++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                prev = colPtr;<br>                colPtr = colPtr-&gt;down;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> delCnt;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵加法"><a href="#矩阵加法" class="headerlink" title="矩阵加法"></a>矩阵加法</h3><blockquote><p>实现三元组表示的两个稀疏矩阵的加法。相关定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100          <span class="hljs-comment">//假设非零元个数的最大值为100</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> i,j;									<span class="hljs-comment">//非零元的行下标和列下标，i 和 j 从 1 开始计数，与数学中矩阵元素的编号一致</span><br>    ElemType e;						<span class="hljs-comment">//非零元的值</span><br>&#125;Triple;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    Triple data[MAXSIZE];			<span class="hljs-comment">// 非零元三元组表</span><br>    <span class="hljs-type">int</span>    m, n, len;							<span class="hljs-comment">// 矩阵的行数、列数和非零元个数</span><br>&#125;TSMatrix;<br></code></pre></td></tr></table></figure><p>在三元组中，<strong>i</strong> 和 <strong>j</strong> 从 <strong>1</strong> 开始计数，与数学中矩阵元素的编号一致<br>矩阵加法函数的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">add_matrix</span><span class="hljs-params">(<span class="hljs-type">const</span> TSMatrix *pM, <span class="hljs-type">const</span> TSMatrix *pN, TSMatrix *pQ)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>pM</strong>, <strong>pN</strong>, <strong>pQ</strong> 分别指向三个矩阵，当 <strong>pM</strong> 和 <strong>pN</strong> 两个矩阵不可加时，函数返回 <strong>false</strong>，否则函数返回 <strong>true</strong>，且 <strong>pQ</strong> 指向两个矩阵的和。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tsmatrix.h&quot;</span></span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">add_matrix</span><span class="hljs-params">(<span class="hljs-type">const</span> TSMatrix *pM, <span class="hljs-type">const</span> TSMatrix *pN, TSMatrix *pQ)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ((pM-&gt;m != pN-&gt;m) || pM-&gt;n != pN-&gt;n)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    pQ-&gt;m = pM-&gt;m;<br>    pQ-&gt;n = pM-&gt;n;<br>    pQ-&gt;len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt; pM-&gt;len &amp;&amp; j &lt; pN-&gt;len)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((pM-&gt;data[i].i &lt; pN-&gt;data[j].i) || (pM-&gt;data[i].i == pN-&gt;data[j].i &amp;&amp; pM-&gt;data[i].j &lt; pN-&gt;data[j].j))<br>            pQ-&gt;data[k++] = pM-&gt;data[i++];<br><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pM-&gt;data[i].i &gt; pN-&gt;data[j].i) || (pM-&gt;data[i].i == pN-&gt;data[j].i &amp;&amp; pM-&gt;data[i].j &gt; pN-&gt;data[j].j))<br>            pQ-&gt;data[k++] = pN-&gt;data[j++];<br><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pQ-&gt;data[k] = pM-&gt;data[i];<br>            pQ-&gt;data[k].e = pM-&gt;data[i].e + pN-&gt;data[j].e;<br>            <span class="hljs-keyword">if</span> (pQ-&gt;data[k].e)<br>                k++;<br>            i++;<br>            j++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt; pM-&gt;len)<br>        pQ-&gt;data[k++] = pM-&gt;data[i++];<br><br>    <span class="hljs-keyword">while</span> (j &lt; pN-&gt;len)<br>        pQ-&gt;data[k++] = pN-&gt;data[j++];<br><br>    pQ-&gt;len = k;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="哈希表创建"><a href="#哈希表创建" class="headerlink" title="哈希表创建"></a>哈希表创建</h3><blockquote><p>哈希表（ <strong>Hash Table</strong>，也叫散列表），是根据键（ <strong>Key</strong> ）而直接访问在内存存储位置的数据结构。</p><p>也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。</p><p>这个映射函数称做哈希函数，存放记录的数组称做哈希表。</p><p>哈希表相关定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;<br>    HASH_OK,<br>    HASH_ERROR,<br>    HASH_ADDED,<br>    HASH_REPLACED_VALUE,<br>    HASH_ALREADY_ADDED,<br>    HASH_DELETED,<br>    HASH_NOT_FOUND,<br>&#125; HASH_RESULT;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashEntry</span> HashEntry;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashEntry</span>&#123;<br>    <span class="hljs-keyword">union</span>&#123;<br>        <span class="hljs-type">char</span>  *str_value;<br>        <span class="hljs-type">double</span> dbl_value;<br>        <span class="hljs-type">int</span>       int_value;<br>    &#125; key;<br>    <span class="hljs-keyword">union</span>&#123;<br>        <span class="hljs-type">char</span>  *str_value;<br>        <span class="hljs-type">double</span> dbl_value;<br>        <span class="hljs-type">int</span>       int_value;<br>        <span class="hljs-type">long</span>   long_value;<br>        <span class="hljs-type">void</span>  *ptr_value;<br>    &#125; value;<br>    HashEntry *next;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashTable</span>&#123;<br>    HashEntry **bucket;        <br>    <span class="hljs-type">int</span> size;<br>    HASH_RESULT last_error;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashTable</span> HashTable;<br><br><span class="hljs-comment">// 创建大小为hash_size的哈希表，创建成功后返回HashTable类型的指针，否则返回NULL。</span><br><span class="hljs-function">HashTable *<span class="hljs-title">create_hash</span><span class="hljs-params">(<span class="hljs-type">int</span> hash_size)</span></span>;<br></code></pre></td></tr></table></figure><p>哈希表相关说明：</p><ul><li><strong>HASH_RESULT</strong> 类型为相关函数的返回类型</li><li><strong>HashEntry</strong> 为哈希表所保存元素（即键值对 <strong>《key, value》</strong>）类型</li><li><strong>HashTable</strong> 为哈希表，其中 <strong>bucket</strong> 指向大小为 <strong>size</strong> 的、元素类型为 <strong>HashEntry</strong>* 的指针数组</li><li>哈希表采用链地址法处理冲突</li></ul><p>请实现 <strong>create_hash</strong> 函数，创建指定大小的哈希表。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hash.h&quot;</span></span><br><br>HashTable *<span class="hljs-title function_">create_hash</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span><br>&#123;<br>    HashTable *table = (HashTable *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HashTable));<br>    <span class="hljs-keyword">if</span> (table == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">memset</span>(table, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(HashTable));<br><br>    table-&gt;bucket = (HashEntry **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HashEntry *) * size);<br>    <span class="hljs-keyword">if</span> (table-&gt;bucket == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(table);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    table-&gt;size = size;<br><br>    <span class="hljs-built_in">memset</span>(table-&gt;bucket, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(HashEntry *) * size);<br>    <span class="hljs-keyword">return</span> table;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希表添加"><a href="#哈希表添加" class="headerlink" title="哈希表添加"></a>哈希表添加</h3><blockquote><p>哈希表（ <strong>Hash Table</strong>，也叫散列表），是根据键（ <strong>Key</strong> ）而直接访问在内存存储位置的数据结构。</p><p>也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。</p><p>这个映射函数称做哈希函数，存放记录的数组称做哈希表。</p><p>哈希表相关定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;<br>    HASH_OK,<br>    HASH_ERROR,<br>    HASH_ADDED,<br>    HASH_REPLACED_VALUE,<br>    HASH_ALREADY_ADDED,<br>    HASH_DELETED,<br>    HASH_NOT_FOUND,<br>&#125; HASH_RESULT;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashEntry</span> HashEntry;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashEntry</span>&#123;<br>    <span class="hljs-keyword">union</span>&#123;<br>        <span class="hljs-type">char</span>  *str_value;<br>        <span class="hljs-type">double</span> dbl_value;<br>        <span class="hljs-type">int</span>       int_value;<br>    &#125; key;<br>    <span class="hljs-keyword">union</span>&#123;<br>        <span class="hljs-type">char</span>  *str_value;<br>        <span class="hljs-type">double</span> dbl_value;<br>        <span class="hljs-type">int</span>       int_value;<br>        <span class="hljs-type">long</span>   long_value;<br>        <span class="hljs-type">void</span>  *ptr_value;<br>    &#125; value;<br>    HashEntry *next;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashTable</span>&#123;<br>    HashEntry **bucket;        <br>    <span class="hljs-type">int</span> size;<br>    HASH_RESULT last_error;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__HashTable</span> HashTable;<br><br><span class="hljs-comment">// 向哈希表中添加元素，其中键类型为char*， 元素类型为int。</span><br><span class="hljs-function">HASH_RESULT <span class="hljs-title">hash_add_int</span><span class="hljs-params">(HashTable * table, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * key, <span class="hljs-type">int</span> value)</span></span>;<br></code></pre></td></tr></table></figure><p>哈希表相关说明：</p><ul><li><strong>HASH_RESULT</strong> 类型为相关函数的返回类型</li><li><strong>HashEntry</strong> 为哈希表所保存元素（即键值对 <strong>《key, value》</strong>）类型</li><li><strong>HashTable</strong> 为哈希表，其中 <strong>bucket</strong> 指向大小为 <strong>size</strong> 的、元素类型为 <strong>HashEntry</strong>* 的指针数组</li><li>哈希表采用链地址法处理冲突</li></ul><p>请实现 <strong>hash_add_int</strong> 函数，向哈希表中添加元素，其中键类型为 <strong>char</strong>* ， 元素类型为 <strong>int</strong> 。在添加过程中，如果要添加的键值 <strong>key</strong> 已在哈希表中，且对应的值 <strong>value</strong> 也已存在，则函数返回 <strong>HASH_ALREADY_ADDED</strong> ；如果要添加的键值 <strong>key</strong> 已在哈希表中，但对应的值 <strong>value</strong> 不同，则函数将 <strong>value</strong> 值更新到哈希表中，之后返回 <strong>HASH_REPLACED_VALUE</strong> ；如果要添加的键值 <strong>key</strong> 不在哈希表中，则函数创建 <strong>HashEntry</strong> 类型，并将其加入到哈希表中，且函数返回 <strong>HASH_ADDED</strong>。</p><p>本题所用的哈希函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">hash_string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> hash = <span class="hljs-number">5381</span>;<br>    <span class="hljs-type">int</span> c;<br><br>    <span class="hljs-keyword">while</span> (c = *str++)<br>        hash = ((hash &lt;&lt; <span class="hljs-number">5</span>) + hash) + c; <span class="hljs-comment">/* hash * 33 + c */</span><br>    <span class="hljs-keyword">if</span>(hash &lt; <span class="hljs-number">0</span>)<br>        hash *= <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> hash;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hash.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br>HASH_RESULT <span class="hljs-title function_">hash_add_int</span><span class="hljs-params">(HashTable *table, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> value)</span><br>&#123;<br>    <span class="hljs-type">long</span> hash = hash_string(key);<br><br>    <span class="hljs-type">int</span> index = hash % table-&gt;size;<br><br>    HashEntry *hashPtr = table-&gt;bucket[index];<br>    <span class="hljs-comment">// HashEntry *prev = NULL;</span><br>    <span class="hljs-keyword">while</span> (hashPtr)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(hashPtr-&gt;key.str_value, key) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (hashPtr-&gt;value.int_value == value)<br>                <span class="hljs-keyword">return</span> HASH_ALREADY_ADDED;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                hashPtr-&gt;value.int_value = value;<br>                <span class="hljs-keyword">return</span> HASH_REPLACED_VALUE;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// prev = hashPtr;</span><br>        hashPtr = hashPtr-&gt;next;<br>    &#125;<br><br>    HashEntry *newEntry = (HashEntry *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HashEntry));<br>    <span class="hljs-keyword">if</span> (newEntry == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        table-&gt;last_error = HASH_ERROR;<br>        <span class="hljs-keyword">return</span> HASH_ERROR;<br>    &#125;<br>    newEntry-&gt;key.str_value = strdup(key);<br>    newEntry-&gt;value.int_value = value;<br>    <span class="hljs-comment">// newEntry-&gt;next = NULL;</span><br>    newEntry-&gt;next = table-&gt;bucket[index];<br>    table-&gt;bucket[index] = newEntry;<br>    <span class="hljs-comment">// if (prev == NULL)</span><br>    <span class="hljs-comment">//     table-&gt;bucket[index] = newEntry;</span><br>    <span class="hljs-comment">// else</span><br>    <span class="hljs-comment">//     prev-&gt;next = newEntry;</span><br>    <span class="hljs-keyword">return</span> HASH_ADDED;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AVL添加"><a href="#AVL添加" class="headerlink" title="AVL添加"></a>AVL添加</h3><blockquote><p>平衡二叉树，是一种二叉排序树，其中每个结点的左子树和右子树的高度差至多等于 <strong>1</strong> 。它是一种高度平衡的二叉排序树。</p><p>现二叉平衡树结点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *left;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *right;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *parent;<br>    <span class="hljs-type">int</span> height;<br>&#125; <span class="hljs-type">node_t</span>;<br></code></pre></td></tr></table></figure><p>请实现平衡二叉树的插入算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//向根为 root 的平衡二叉树插入新元素 val，成功后返回新平衡二叉树根结点</span><br><span class="hljs-function"><span class="hljs-type">node_t</span> *<span class="hljs-title">avl_insert</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *root, <span class="hljs-type">int</span> val)</span></span>;<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;avl.h&quot;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_height</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *root)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(get_height(root-&gt;left), get_height(root-&gt;right));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_balance_factor</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *root)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> get_height(root-&gt;left) - get_height(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          2:Y</span><br><span class="hljs-comment">           / \</span><br><span class="hljs-comment">        1:X   YL</span><br><span class="hljs-comment">         / \</span><br><span class="hljs-comment">   1/-1:XL  XR</span><br><span class="hljs-comment">       /  \</span><br><span class="hljs-comment">NEW:  A    B</span><br><span class="hljs-comment">        or</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">--RightRotation</span><br><span class="hljs-comment">==&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          0: X</span><br><span class="hljs-comment">           /   \</span><br><span class="hljs-comment">        0:XL    Y</span><br><span class="hljs-comment">         / \   / \</span><br><span class="hljs-comment">        A   B XR  YL</span><br><span class="hljs-comment">          or</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">node_t</span> *<span class="hljs-title function_">right_rotate</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *y)</span><br>&#123;<br>    <span class="hljs-type">node_t</span> *x = y-&gt;left;<br>    y-&gt;left = x-&gt;right;<br>    x-&gt;right = y;<br><br>    y-&gt;parent = x;<br>    <span class="hljs-keyword">if</span> (y-&gt;left != <span class="hljs-literal">NULL</span>)<br>        y-&gt;left-&gt;parent = y;<br><br>    y-&gt;height = get_height(y);<br>    x-&gt;height = get_height(x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            Y:2</span><br><span class="hljs-comment">           / \</span><br><span class="hljs-comment">          YL  X:1</span><br><span class="hljs-comment">             / \</span><br><span class="hljs-comment">            XL  XR:1/-1</span><br><span class="hljs-comment">               / \</span><br><span class="hljs-comment">        NEW:  A   B</span><br><span class="hljs-comment">                or</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">--LeftRotation</span><br><span class="hljs-comment">==&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">             X:0</span><br><span class="hljs-comment">           /   \</span><br><span class="hljs-comment">          Y     XR:1/-1</span><br><span class="hljs-comment">         / \   /  \</span><br><span class="hljs-comment">        YL  XL A   B</span><br><span class="hljs-comment">                 or</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">node_t</span> *<span class="hljs-title function_">left_rotate</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *y)</span><br>&#123;<br>    <span class="hljs-type">node_t</span> *x = y-&gt;right;<br>    y-&gt;right = x-&gt;left;<br>    x-&gt;left = y;<br><br>    y-&gt;parent = x;<br>    <span class="hljs-keyword">if</span> (y-&gt;right != <span class="hljs-literal">NULL</span>)<br>        y-&gt;right-&gt;parent = y;<br><br>    y-&gt;height = get_height(y);<br>    x-&gt;height = get_height(x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-type">node_t</span> *<span class="hljs-title function_">avl_insert</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *root, <span class="hljs-type">int</span> val)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-type">node_t</span> *newNode = (<span class="hljs-type">node_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>));<br>        newNode-&gt;val = val;<br>        newNode-&gt;left = <span class="hljs-literal">NULL</span>;<br>        newNode-&gt;right = <span class="hljs-literal">NULL</span>;<br>        newNode-&gt;parent = <span class="hljs-literal">NULL</span>;<br>        newNode-&gt;height = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (val &lt; root-&gt;val)<br>    &#123;<br>        root-&gt;left = avl_insert(root-&gt;left, val);<br>        root-&gt;left-&gt;parent = root;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; root-&gt;val)<br>    &#123;<br><br>        root-&gt;right = avl_insert(root-&gt;right, val);<br>        root-&gt;right-&gt;parent = root;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    root-&gt;height = get_height(root);<br><br>    <span class="hljs-type">int</span> bf = get_balance_factor(root);<br><br>    <span class="hljs-comment">// LL</span><br>    <span class="hljs-keyword">if</span> (bf &gt; <span class="hljs-number">1</span> &amp;&amp; val &lt; root-&gt;left-&gt;val)<br>        <span class="hljs-keyword">return</span> right_rotate(root);<br><br>    <span class="hljs-comment">// LR</span><br>    <span class="hljs-keyword">if</span> (bf &gt; <span class="hljs-number">1</span> &amp;&amp; val &gt; root-&gt;left-&gt;val)<br>    &#123;<br>        root-&gt;left = left_rotate(root-&gt;left);<br>        <span class="hljs-keyword">return</span> right_rotate(root);<br>    &#125;<br><br>    <span class="hljs-comment">// RR</span><br>    <span class="hljs-keyword">if</span> (bf &lt; <span class="hljs-number">-1</span> &amp;&amp; val &gt; root-&gt;right-&gt;val)<br>        <span class="hljs-keyword">return</span> left_rotate(root);<br><br>    <span class="hljs-comment">// RL</span><br>    <span class="hljs-keyword">if</span> (bf &lt; <span class="hljs-number">-1</span> &amp;&amp; val &lt; root-&gt;right-&gt;val)<br>    &#123;<br>        root-&gt;right = right_rotate(root-&gt;right);<br>        <span class="hljs-keyword">return</span> left_rotate(root);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><center><font size="6" color="red">所有答案仅供参考！！！</font></center></div><hr><div><div class="post-metas my-3"><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/iCoding/" class="print-no-link">#iCoding</a></div></div><div class="license-box my-3"><div class="license-title"><div>UESTC-iCoding-F2</div><div>http://example.com/posts/72dd718d/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Fanllspd</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年6月7日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年7月1日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/posts/5ae288a7/" title="HNCTF-2024"><span class="hidden-mobile">HNCTF-2024</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createCssLink("https://cdn.staticfile.org/waline/2.15.5/waline.min.css"),Fluid.utils.createScript("https://cdn.staticfile.org/waline/2.15.5/waline.min.js",(function(){var e=Object.assign({serverURL:"https://waline-comments-blue.vercel.app/",locale:{placeholder:"Share something plz~~"},avatar:"robohash",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10,reaction:!0},{el:"#waline",path:window.location.pathname});Waline.init(e),fetch("https://api.xygeng.cn/One").then(e=>e.json()).then(e=>{document.getElementById("wl-edit").placeholder=`${e.data.content}--${e.data.origin}`}).catch(console.error),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var e="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({easing:"ease",speed:500,showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/yinghua.js"></script><script src="/js/BgLine.js"></script><script src="/js/walinePlaceHolder.js"></script><script src="/js/scrollAnimation.js"></script><script src="/js/backgroundize.js"></script><script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script>var endLoading=function(){document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")};window.addEventListener("load",endLoading)</script></body></html>